Design choices (talk track for your presentation)
Auth method: JWT Bearer with Spring Security 6. It’s stateless, simple to scale behind load balancers, and easy to integrate across clients. Passwords hashed with BCrypt.

Aggregation flow: Three independent public providers via WebClient (non‑blocking). For each pair, compute a provider average, then apply a configurable markup (ABSOLUTE: +0.10 by default; flip to PERCENT if business prefers +10%).

Data model: RateRecord stores the canonical pair, average before markup, applied markup, final rate, and timestamp for auditable history.

Refresh strategy: Hourly @Scheduled job (plus warmup at boot). If a fetch fails, we keep the last good snapshot; manual refresh endpoint provided for ops.

Scalability for more pairs: Add pairs to app.aggregation.pairs and generalize provider parsing if needed. The service is naturally horizontally scalable (stateless app, DB-backed history). WebClient is non-blocking; can parallelize providers and pairs if needed.

Extensibility: Add an interface ProviderClient so you can plug more sources or paid APIs with keys (via env vars). Add caching/CDN in front of /rates if read-heavy.